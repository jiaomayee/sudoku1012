// 测试修复后的XYZ-Wing算法

// 从sudokuTechniques.js导入findXYZWing函数
import pkg from './frontend/src/utils/sudokuTechniques.js';
const { findXYZWing } = pkg;

// 测试棋盘: 包含一个典型的XYZ-Wing模式
const xyzWingTestBoard = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0]
];

// 测试候选数: 包含一个典型的XYZ-Wing模式
const xyzWingTestPencilNotes = {
  // 枢纽单元格(中心): 包含三个候选数[1, 2, 3]
  "4-4": [1, 2, 3],
  
  // XZ单元格: 包含两个候选数[1, 2]
  "4-1": [1, 2],
  
  // YZ单元格: 包含两个候选数[2, 3]
  "1-4": [2, 3],
  
  // 目标单元格: 包含候选数[2]，与XZ和YZ单元格在同一行、列或宫
  "1-1": [2, 4, 5],
  
  // 其他单元格的候选数
  "0-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "0-1": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "0-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "0-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "0-4": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "0-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "0-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "0-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "0-8": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  
  "1-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "1-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "1-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "1-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "1-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "1-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "1-8": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  
  "2-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "2-1": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "2-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "2-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "2-4": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "2-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "2-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "2-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "2-8": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  
  "3-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "3-1": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "3-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "3-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "3-4": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "3-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "3-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "3-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "3-8": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  
  "4-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "4-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "4-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "4-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "4-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "4-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "4-8": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  
  "5-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "5-1": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "5-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "5-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "5-4": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "5-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "5-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "5-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "5-8": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  
  "6-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "6-1": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "6-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "6-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "6-4": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "6-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "6-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "6-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "6-8": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  
  "7-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "7-1": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "7-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "7-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "7-4": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "7-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "7-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "7-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "7-8": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  
  "8-0": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "8-1": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "8-2": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "8-3": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "8-4": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "8-5": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "8-6": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "8-7": [1, 2, 3, 4, 5, 6, 7, 8, 9],
  "8-8": [1, 2, 3, 4, 5, 6, 7, 8, 9]
};

// 运行测试
function runXYZWingTest() {
  console.log("=== 开始测试修复后的XYZ-Wing算法 ===");
  
  try {
    // 调用修复后的findXYZWing函数
    const results = findXYZWing(xyzWingTestBoard, xyzWingTestPencilNotes);
    
    console.log("\n测试结果:");
    console.log(`找到 ${results.length} 个XYZ-Wing机会`);
    
    if (results.length > 0) {
      // 分析第一个结果
      const result = results[0];
      
      console.log("\n第一个XYZ-Wing模式详情:");
      console.log(`- 枢纽单元格: (${result.pivotCell[0] + 1}, ${result.pivotCell[1] + 1})`);
      console.log(`- XZ单元格: (${result.xzCell[0] + 1}, ${result.xzCell[1] + 1})`);
      console.log(`- YZ单元格: (${result.yzCell[0] + 1}, ${result.yzCell[1] + 1})`);
      console.log(`- x, y, z 值: ${result.x}, ${result.y}, ${result.z}`);
      console.log(`- 目标单元格数量: ${result.targetCells.length}`);
      
      // 检查是否找到了正确的目标单元格(1,1)
      const foundTargetCell = result.targetCells.some(cell => cell[0] === 1 && cell[1] === 1);
      console.log(`\n是否正确识别目标单元格(1,1): ${foundTargetCell ? '✓' : '✗'}`);
      
      // 检查是否只尝试删除候选数2
      const removesOnlyCandidate2 = result.targetCellsDetails.every(detail => 
        detail.notesToRemove.length === 1 && detail.notesToRemove[0] === 2
      );
      console.log(`是否只尝试删除候选数2: ${removesOnlyCandidate2 ? '✓' : '✗'}`);
      
      // 输出所有目标单元格和要删除的候选数
      console.log("\n目标单元格和要删除的候选数:");
      result.targetCellsDetails.forEach(detail => {
        console.log(`- 单元格(${detail.row + 1}, ${detail.col + 1}): 删除候选数 ${detail.notesToRemove.join(', ')}`);
      });
      
      // 验证测试是否通过
      if (foundTargetCell && removesOnlyCandidate2) {
        console.log("\n✅ 测试通过! XYZ-Wing算法正确识别模式并只删除应该删除的候选数。");
      } else {
        console.log("\n❌ 测试失败! XYZ-Wing算法识别不正确。");
      }
    } else {
      console.log("\n❌ 测试失败! 没有找到预期的XYZ-Wing模式。");
    }
    
  } catch (error) {
    console.error("\n❌ 测试运行出错:", error);
  }
  
  console.log("\n=== XYZ-Wing算法测试完成 ===");
}

// 执行测试
runXYZWingTest();